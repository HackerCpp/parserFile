#include "inc/parsers/parser38k.h"
#include <QTextCodec>
#include <QTime>

void paramFlashGKT(QString & data,QByteArray &ba){
    data += "<tr><td>ttotal_length </td><td> %1</td></tr>\
<tr><td>telemetry_speed </td><td> %2</td></tr>\
<tr><td>telemetry_resolution </td><td> %3</td></tr>\
<tr><td>resistance_divisor </td><td> %4</td></tr>\
<tr><td>resistance_phase_one </td><td> %5</td></tr>\
<tr><td>resistance_phase_two </td><td> %6</td></tr>\
<tr><td>gk_dac_set_value </td><td> %7</td></tr>\
<tr><td>gk_dac_min_value </td><td> %8</td></tr>\
<tr><td>gk_dac_max_value </td><td> %9</td></tr>\
<tr><td>hygro_hi_prescaler </td><td> %10</td></tr>\
<tr><td>hygro_hi_timeout </td><td> %11</td></tr>\
<tr><td>hygro_lo_pulses </td><td> %12</td></tr>\
<tr><td>sti_max_temperature </td><td> %13</td></tr>\
<tr><td>sti_min_temperature </td><td> %14</td></tr>\
<tr><td>emds_disabled </td><td> %15</td></tr>\
<tr><td>gk_noisemeter_mode </td><td> %16</td></tr>\
<tr><td>sti_start_duty_value </td><td> %17</td></tr>\
<tr><td>extern_adc_temperature_config </td><td> %18</td></tr>\
<tr><td>extern_adc_std_config </td><td> %19</td></tr>\
<tr><td>extern_adc_pcorr_config </td><td> %20</td></tr>\
<tr><td>extern_adc_pbw_config </td><td> %21</td></tr>\
<tr><td>extern_adc_locator_config </td><td> %22</td></tr>\
<tr><td>extern_adc_accel_config </td><td> %23</td></tr>\
<tr><td>extern_adc_resist_config </td><td> %24</td></tr>\
<tr><td>add_command_dump </td><td> %25</td></tr>\
<tr><td>temperature_volatile </td><td> %26</td></tr>\
<tr><td>temperature_volatile </td><td> %27</td></tr>\
<tr><td>gk_dac_temperature_volatile </td><td> %28</td></tr>\
<tr><td>gk_dac_temperature_maximum </td><td> %29</td></tr>\
<tr><td>temperature_addition </td><td> %30</td></tr>\
<tr><td>reserve </td><td> %31</td></tr>\
<tr><td>extern_adc_locator_offset </td><td> %32</td></tr>\
<tr><td>CRC16 </td><td> %33</td></tr>";
            data = data.arg(*reinterpret_cast<ushort*>(ba.data()))
            .arg(*reinterpret_cast<uchar*>(ba.data()+2)).arg(*reinterpret_cast<uchar*>(ba.data()+3))
            .arg(*reinterpret_cast<ushort*>(ba.data()+4))
            .arg(*reinterpret_cast<ushort*>(ba.data()+6))
            .arg(*reinterpret_cast<ushort*>(ba.data()+8))
            .arg(*reinterpret_cast<ushort*>(ba.data()+10))
            .arg(*reinterpret_cast<ushort*>(ba.data()+12))
            .arg(*reinterpret_cast<ushort*>(ba.data()+14))
            .arg(*reinterpret_cast<ushort*>(ba.data()+16))
            .arg(*reinterpret_cast<ushort*>(ba.data()+18))
            .arg(*reinterpret_cast<ushort*>(ba.data()+20))
            .arg(*reinterpret_cast<uint*>(ba.data()+22))
            .arg(*reinterpret_cast<uint*>(ba.data()+26))
            .arg(*reinterpret_cast<uchar*>(ba.data()+30)).arg(*reinterpret_cast<uchar*>(ba.data()+31))
            .arg(*reinterpret_cast<ushort*>(ba.data()+32))
            .arg(*reinterpret_cast<ushort*>(ba.data()+34))
            .arg(*reinterpret_cast<ushort*>(ba.data()+36))
            .arg(*reinterpret_cast<ushort*>(ba.data()+38))
            .arg(*reinterpret_cast<ushort*>(ba.data()+40))
            .arg(*reinterpret_cast<ushort*>(ba.data()+42))
            .arg(*reinterpret_cast<ushort*>(ba.data()+44))
            .arg(*reinterpret_cast<ushort*>(ba.data()+46))
            .arg(*reinterpret_cast<uchar*>(ba.data()+48))
            .arg(*reinterpret_cast<float*>(ba.data()+49))
            .arg(*reinterpret_cast<float*>(ba.data()+53))
            .arg(*reinterpret_cast<ushort*>(ba.data()+57))
            .arg(*reinterpret_cast<ushort*>(ba.data()+59))
            .arg(*reinterpret_cast<ushort*>(ba.data()+61))
            .arg(*reinterpret_cast<uint*>(ba.data()+63))
            .arg(*reinterpret_cast<uint*>(ba.data()+67))
            .arg(*reinterpret_cast<uchar*>(ba.data()+71));
}

void paramFlashSHM(QString & data,QByteArray &ba){
    data += "<tr><td>total_length </td><td> %1</td></tr>\
<tr><td>sensors_number </td><td> %2</td></tr>\
<tr><td>channel_coefficients </td><td> %3</td></tr>\
<tr><td>head_to_sensor_length </td><td> %4</td></tr>\
<tr><td>startup_mode : %5</td></tr>\
<tr><td>hardware_swap_channels </td><td> %6</td></tr>\
<tr><td>hardware_invert_channels </td><td> %7</td></tr>\
<tr><td>acoustics_startup_channels </td><td> %8</td></tr>\
<tr><td>acoustics_startup_adc_time </td><td> %9</td></tr>\
<tr><td>acoustics_startup_period </td><td> %10</td></tr>\
<tr><td>acoustics_start_offset </td><td> %11</td></tr>\
<tr><td>acoustics_gain </td><td> %12</td></tr>\
<tr><td>acoustics_gain_off_words </td><td> %13</td></tr>\
<tr><td>acoustics_preconversion_pause </td><td> %14</td></tr>\
<tr><td>generator_wait_interval </td><td> %15</td></tr>\
<tr><td>noisemeter_startup_channels </td><td> %16</td></tr>\
<tr><td>noisemeter_startup_words </td><td> %17</td></tr>\
<tr><td>noisemeter_startup_freq </td><td> %18</td></tr>\
<tr><td>noisemeter_warm_cycles </td><td> %19</td></tr>\
<tr><td>noisemeter_window_fuction </td><td> %20</td></tr>\
<tr><td>noisemeter_smooth_number </td><td> %21</td></tr>\
<tr><td>noisemeter_gain </td><td> %22</td></tr>\
<tr><td>noisemeter_gain_off_words </td><td> %23</td></tr>\
<tr><td>noisemeter_preconversion_pause </td><td> %24</td></tr>\
<tr><td>part_max_size </td><td> %25</td></tr>\
<tr><td>movement_variance_limit </td><td> %26</td></tr>\
<tr><td>variance_settle_period </td><td> %27</td></tr>\
<tr><td>bus_survey </td><td> %28</td></tr>\
<tr><td>reserve </td><td> %29</td></tr>\
<tr><td>crc16 </td><td> %30</td></tr>";
            data = data.arg(*reinterpret_cast<ushort*>(ba.data()))
            .arg(*reinterpret_cast<ushort*>(ba.data()+2))
            .arg(QString::number(*reinterpret_cast<float*>(ba.data()+4)) + " " +
                 QString::number(*reinterpret_cast<float*>(ba.data()+8)))
            .arg(QString::number(*reinterpret_cast<ushort*>(ba.data()+12)) + " " +
                 QString::number(*reinterpret_cast<ushort*>(ba.data()+14)))
            .arg(*reinterpret_cast<ushort*>(ba.data()+16))
            .arg(*reinterpret_cast<ushort*>(ba.data()+18))
            .arg(*reinterpret_cast<ushort*>(ba.data()+20))
            .arg(*reinterpret_cast<ushort*>(ba.data()+22))
            .arg(*reinterpret_cast<ushort*>(ba.data()+24))
            .arg(*reinterpret_cast<ushort*>(ba.data()+26))
            .arg(*reinterpret_cast<ushort*>(ba.data()+28))
            .arg(*reinterpret_cast<uchar*>(ba.data()+30))
            .arg(*reinterpret_cast<ushort*>(ba.data()+31))
            .arg(*reinterpret_cast<ushort*>(ba.data()+33))
            .arg(*reinterpret_cast<ushort*>(ba.data()+35))
            .arg(*reinterpret_cast<ushort*>(ba.data()+37))
            .arg(*reinterpret_cast<ushort*>(ba.data()+39))
            .arg(*reinterpret_cast<uint*>(ba.data()+41))
            .arg(*reinterpret_cast<ushort*>(ba.data()+45))
            .arg(*reinterpret_cast<ushort*>(ba.data()+47))
            .arg(QString::number(*reinterpret_cast<ushort*>(ba.data()+49)) + " " +
                 QString::number(*reinterpret_cast<ushort*>(ba.data()+51)))
            .arg(*reinterpret_cast<uchar*>(ba.data()+53))
            .arg(*reinterpret_cast<ushort*>(ba.data()+54))
            .arg(*reinterpret_cast<ushort*>(ba.data()+56))
            .arg(*reinterpret_cast<ushort*>(ba.data()+58))
            .arg(*reinterpret_cast<uint*>(ba.data()+60))
            .arg(*reinterpret_cast<ushort*>(ba.data()+64))
            .arg(*reinterpret_cast<ushort*>(ba.data()+66))
            .arg("reserve")
            .arg(*reinterpret_cast<ushort*>(ba.data()+76));
}

void paramFlashAG(QString & data,QByteArray &ba){
    data += "<tr><td>total_length </td><td> %1</td></tr>\
<tr><td>head_to_discharger_length </td><td> %2</td></tr>\
<tr><td>click_interval_low_freq </td><td> %3</td></tr>\
<tr><td>click_interval_hi_freq </td><td> %4</td></tr>\
<tr><td>click_channel </td><td> %5</td></tr>\
<tr><td>stop_pwm_interval </td><td> %6</td></tr>\
<tr><td>wait_interval </td><td> %7</td></tr>\
<tr><td>start_pwm_interval </td><td> %8</td></tr>\
<tr><td>reception_enable_interval </td><td> %9</td></tr>\
<tr><td>pwm_period </td><td> %10</td></tr>\
<tr><td>set_voltage </td><td> %11</td></tr>\
<tr><td>CRC16 </td><td> %12</td></tr>";
            data = data.arg(*reinterpret_cast<ushort*>(ba.data()))
            .arg(*reinterpret_cast<ushort*>(ba.data()+2))
            .arg(*reinterpret_cast<ushort*>(ba.data()+4))
            .arg(*reinterpret_cast<ushort*>(ba.data()+6))
            .arg(*reinterpret_cast<uchar*>(ba.data()+8))
            .arg(*reinterpret_cast<ushort*>(ba.data()+9))
            .arg(*reinterpret_cast<ushort*>(ba.data()+11))
            .arg(*reinterpret_cast<ushort*>(ba.data()+13))
            .arg(*reinterpret_cast<ushort*>(ba.data()+15))
            .arg(*reinterpret_cast<ushort*>(ba.data()+17))
            .arg(*reinterpret_cast<ushort*>(ba.data()+19))
            .arg(*reinterpret_cast<ushort*>(ba.data()+21));
}
void paramFlashP(QString & data,QByteArray &ba){
    data += "<tr><td>total_length </td><td> %1</td></tr>\
             <tr><td>CRC16 </td><td> %2</td></tr>";
            data = data.arg(*reinterpret_cast<ushort*>(ba.data()))
            .arg(*reinterpret_cast<ushort*>(ba.data()+2));
}
void paramFlashP0204(QString & data,QByteArray &ba){
    data += "<tr><td>total_length </td><td> %1</td></tr>\
<tr><td>channel_1_offset </td><td> %2</td></tr>\
<tr><td>channel_2_offset </td><td> %3</td></tr>\
<tr><td>invert_rate_signum </td><td> %4</td></tr>\
<tr><td>CRC16 </td><td> %5</td></tr>";
            data = data.arg(*reinterpret_cast<ushort*>(ba.data()))
            .arg(*reinterpret_cast<ushort*>(ba.data()+2))
            .arg(*reinterpret_cast<ushort*>(ba.data()+4))
            .arg(*reinterpret_cast<uchar*>(ba.data()+6))
            .arg(*reinterpret_cast<ushort*>(ba.data()+7));
}
void paramFlashGVK(QString & data,QByteArray &ba){
    data += "<tr><td>total_length </td><td> %1</td></tr>\
<tr><td>telemetry_speed </td><td> %2</td></tr>\
<tr><td>telemetry_resolution </td><td> %3</td></tr>\
<tr><td>gk_dac_set_value </td><td> %4</td></tr>\
<tr><td>gk_dac_min_value : %5</td></tr>\
<tr><td>gk_dac_max_value </td><td> %6</td></tr>\
<tr><td>extern_adc_temperature_config </td><td> %7</td></tr>\
<tr><td>extern_adc_temperature_2_config </td><td> %8</td></tr>\
<tr><td>extern_adc_pcorr_config </td><td> %9</td></tr>\
<tr><td>extern_adc_pbw_config </td><td> %10</td></tr>\
<tr><td>extern_adc_locator_config </td><td> %11</td></tr>\
<tr><td>extern_adc_accel_config </td><td> %12</td></tr>\
<tr><td>extern_adc_temperature_4_config </td><td> %13</td></tr>\
<tr><td>reserve </td><td> %14</td></tr>\
<tr><td>temperature_volatile </td><td> %15</td></tr>\
<tr><td>temperature_maximum </td><td> %16</td></tr>\
<tr><td>gk_dac_temperature_volatile </td><td> %17</td></tr>\
<tr><td>gk_dac_temperature_maximum </td><td> %18</td></tr>\
<tr><td>reserve </td><td> %19</td></tr>\
<tr><td>reserve </td><td> %20</td></tr>\
<tr><td>extern_adc_locator_offset </td><td> %21</td></tr>\
<tr><td>crc16 </td><td> %22</td></tr>";
            data = data.arg(*reinterpret_cast<ushort*>(ba.data()))
            .arg(*reinterpret_cast<uchar*>(ba.data()+2)).arg(*reinterpret_cast<uchar*>(ba.data()+3))
            .arg(*reinterpret_cast<ushort*>(ba.data()+4))
            .arg(*reinterpret_cast<short*>(ba.data()+6))
            .arg(*reinterpret_cast<short*>(ba.data()+8))
            .arg(*reinterpret_cast<ushort*>(ba.data()+10))
            .arg(*reinterpret_cast<ushort*>(ba.data()+12))
            .arg(*reinterpret_cast<ushort*>(ba.data()+14))
            .arg(*reinterpret_cast<ushort*>(ba.data()+16))
            .arg(*reinterpret_cast<ushort*>(ba.data()+18))
            .arg(*reinterpret_cast<ushort*>(ba.data()+20))
            .arg(*reinterpret_cast<ushort*>(ba.data()+22))
            .arg(*reinterpret_cast<uchar*>(ba.data()+24))
            .arg(*reinterpret_cast<float*>(ba.data()+25))
            .arg(*reinterpret_cast<float*>(ba.data()+29))    
            .arg(*reinterpret_cast<ushort*>(ba.data()+33))
            .arg(*reinterpret_cast<ushort*>(ba.data()+35))
            .arg(*reinterpret_cast<ushort*>(ba.data()+37))
            .arg(*reinterpret_cast<uint*>(ba.data()+39))
            .arg(*reinterpret_cast<uint*>(ba.data()+43))
            .arg(*reinterpret_cast<ushort*>(ba.data()+47));
}
void channelGKT(QString * data){
    bool ok;
    QString channel = "\n\ttemperature_internal : %1\n\t\
locator_amp : %2\n\t\
locator_amp_interval_max : %3\n\t\
locator_amp_interval_min : %4\n\t\
gk_time : %5\n\t\
gk_impulses : %6\n\t\
gk_uhv : %7\n\t\
hygrometer : %8\n\t\
power_supply : %9\n\t\
emds_supply : %10\n\t\
temperature_external : %11\n\t\
sti_1 : %12\n\t\
sti_2 : %13\n\t\
p_corr : %14\n\t\
p_bw : %15\n\t\
acceleration_x : %16\n\t\
acceleration_y : %17\n\t\
acceleration_z : %18\n\t\
locator_amp : %19\n\t\
resistance : %20\n\t\
sti_pwm : %21\n\t\
pressure : %22\n\t\
temperature : %23\n\t\
gk_dac : %24\n\t";
            channel = channel.arg(((*data).mid(2,2) + (*data).mid(0,2)).toUInt(&ok,16))
            .arg(((*data).mid(6,2) + (*data).mid(4,2)).toUInt(&ok,16))
            .arg(((*data).mid(10,2) + (*data).mid(8,2)).toUInt(&ok,16))
            .arg(((*data).mid(14,2) + (*data).mid(12,2)).toUInt(&ok,16))
            .arg(((*data).mid(18,2) + (*data).mid(16,2)).toUInt(&ok,16))
            .arg(((*data).mid(22,2) + (*data).mid(20,2)).toUInt(&ok,16))
            .arg(((*data).mid(26,2) + (*data).mid(24,2)).toUInt(&ok,16))
            .arg(((*data).mid(30,2) + (*data).mid(28,2)).toUInt(&ok,16))
            .arg(((*data).mid(34,2) + (*data).mid(32,2)).toUInt(&ok,16))
            .arg(((*data).mid(38,2) + (*data).mid(36,2)).toUInt(&ok,16))
            .arg(((*data).mid(44,2) + (*data).mid(42,2)+ (*data).mid(40,2)).toUInt(&ok,16))
            .arg(((*data).mid(50,2) + (*data).mid(48,2)+ (*data).mid(46,2)).toUInt(&ok,16))
            .arg(((*data).mid(56,2) + (*data).mid(54,2)+ (*data).mid(52,2)).toUInt(&ok,16))
            .arg(((*data).mid(62,2) + (*data).mid(60,2)+ (*data).mid(58,2)).toUInt(&ok,16))
            .arg(((*data).mid(68,2) + (*data).mid(66,2)+ (*data).mid(64,2)).toUInt(&ok,16))
            .arg(((*data).mid(74,2) + (*data).mid(72,2)+ (*data).mid(70,2)).toUInt(&ok,16))
            .arg(((*data).mid(80,2) + (*data).mid(78,2)+ (*data).mid(76,2)).toUInt(&ok,16))
            .arg(((*data).mid(86,2) + (*data).mid(84,2)+ (*data).mid(82,2)).toUInt(&ok,16))
            .arg(((*data).mid(92,2) + (*data).mid(90,2)+ (*data).mid(88,2)).toUInt(&ok,16))
            .arg(((*data).mid(98,2) + (*data).mid(96,2)+ (*data).mid(94,2)).toUInt(&ok,16))
            .arg(((*data).mid(102,2) + (*data).mid(100,2)).toUInt(&ok,16))
            .arg(((*data).mid(110,2) + (*data).mid(108,2)+ (*data).mid(106,2)+ (*data).mid(104,2)).toUInt(&ok,16))
            .arg(((*data).mid(118,2) + (*data).mid(116,2)+ (*data).mid(114,2)+ (*data).mid(112,2)).toUInt(&ok,16))
            .arg(((*data).mid(122,2) + (*data).mid(120,2)).toUInt(&ok,16));
    *data = channel;
}

void Parser38kModules::channelSHM(QString * data,unsigned char currentPartNo){
    bool ok;
    int size = (data->size()/2);
    int pos = 0;
    QString channel;
    if(!currentPartNo){
        channel = "\n\tperiph_status : %1\n\t\
work_mode_MSB : %2\n\t\
work_mode_LSB : %3\n\t\
channels_map : %4\n\t\
words_per_channel : %5\n\t\
channel_frequency : %6\n\t\
pga_gain : %7\n\t\
temperature_internal : %8\n\t\
accel_z_mean : %9\n\t\
accel_z_variance : %10\n\t\
accel_z_flags : %11\n\t\
Data :\n\t";
        currentChannel = 0;
        currentWordPerChannel = 0;
        wordPerChannel = ((*data).mid(12,2) + (*data).mid(10,2)).toUInt(&ok,16);
        isWave = ("0"+(*data).mid(7,1)).toUInt(&ok,16);
        channel = channel.arg(((*data).mid(2,2) + (*data).mid(0,2)).toUInt(&ok,16))
            .arg(("0"+(*data).mid(6,1)).toUInt(&ok,16)).arg(isWave)
            .arg(((*data).mid(8,2)).toUInt(&ok,16))
            .arg(wordPerChannel)
            .arg(((*data).mid(20,2) + (*data).mid(18,2)+ (*data).mid(16,2)+ (*data).mid(14,2)).toUInt(&ok,16))
            .arg((*data).mid(22,2).toUInt(&ok,16))
            .arg(((*data).mid(26,2) + (*data).mid(24,2)).toUInt(&ok,16))
            .arg(((*data).mid(30,2) + (*data).mid(28,2)).toUInt(&ok,16))
            .arg(((*data).mid(34,2) + (*data).mid(32,2)).toUInt(&ok,16))
            .arg(((*data).mid(38,2) + (*data).mid(36,2)).toUInt(&ok,16));
        size  = (data->size()/2)-20;
        pos = 42;
    }

    if(!isWave){
        for(int i = 0; i < size;i+=4){
            if(!currentWordPerChannel){
               channel += "\nChannel" + QString::number(currentChannel++) + "\n\n\t";
               currentWordPerChannel = wordPerChannel;
            }
            QByteArray string =  QByteArray::fromHex( ((*data).mid((i*2)+pos+6,2) + (*data).mid((i*2)+pos+4,2) + (*data).mid((i*2)+pos+2,2) + (*data).mid((i*2)+pos,2)).toLocal8Bit());
            channel += " \n\t" + QString::number(*reinterpret_cast<double*>( string.data()));
            currentWordPerChannel--;
        }
    }
    else{
        for(int i = 0; i < size;i+=2){
            if(!currentWordPerChannel){
               channel += "\nChannel" + QString::number(currentChannel) + "\n\n\t";
               currentWordPerChannel = wordPerChannel;
            }
            channel += " \n\t" + QString::number(((*data).mid((i*2)+pos+6,2) + (*data).mid((i*2)+pos+4,2)).toUInt(&ok,16));
            currentWordPerChannel--;
        }
    }
    *data = channel;
}

void channelAG(QString * data){
    bool ok;
    QString channel = "\n\tperiph_status : %1\n\t\
work_mode : %2\n\t\
temperature_internal : %3\n\t\
discharge_voltage : %4\n\t";
            channel = channel.arg(((*data).mid(2,2) + (*data).mid(0,2)).toUInt(&ok,16))
            .arg(((*data).mid(6,2) + (*data).mid(4,2)).toUInt(&ok,16))
            .arg(((*data).mid(10,2) + (*data).mid(8,2)).toUInt(&ok,16))
            .arg(((*data).mid(14,2) + (*data).mid(12,2)).toUInt(&ok,16));
    *data = channel;
}
void channelP(QString * data){
    bool ok;
    QString channel = "\n\tperiph_status : %1\n\t\
angle : %2\n\t\
rate : %3\n\t\
temperature_internal : %4\n\t";
            channel = channel.arg(((*data).mid(2,2) + (*data).mid(0,2)).toUInt(&ok,16))
            .arg(((*data).mid(6,2) + (*data).mid(4,2)).toUInt(&ok,16))
            .arg(QString::number(*reinterpret_cast<double*>( QByteArray::fromHex( ((*data).mid(14,2) + (*data).mid(12,2) + (*data).mid(10,2) + (*data).mid(8,2)).toLocal8Bit()).data() )))
            .arg(((*data).mid(18,2) + (*data).mid(16,2)).toUInt(&ok,16));
    *data = channel;
}

void channelP02(QString * data){
    bool ok;
    QString channel = "\n\trate : %1\n\t\
diameter : %2\n\t\
temperature_internal : %3\n\t";
            channel = channel.arg(QString::number(*reinterpret_cast<double*>( QByteArray::fromHex( ((*data).mid(6,2) + (*data).mid(4,2) + (*data).mid(2,2) + (*data).mid(0,2)).toLocal8Bit()).data() )))
            .arg(((*data).mid(10,2) + (*data).mid(8,2)).toUInt(&ok,16))
            .arg(((*data).mid(14,2) + (*data).mid(12,2)).toUInt(&ok,16));
    *data = channel;
}

void channelP04(QString * data){
    bool ok;
    QString channel = "\n\trate : %1\n\t\
temperature_internal : %2\n\t";
            channel = channel.arg(((*data).mid(2,2) + (*data).mid(0,2)).toUInt(&ok,16))
            .arg(((*data).mid(4,2)).toUInt(&ok,16));
    *data = channel;
}
void channel2NNKt(QString * data){
    bool ok;
    QString channel = "\n\tperiph_status : %1\n\t\
count_time : %2\n\t\
near_count : %3\n\t\
far_count : %4\n\t\
gk_uhv : %5\n\t\
gk_dac : %6\n\t\
temperature_internal : %7\n\t\
comp_edac1_value : %8\n\t\
comp_edac2_value : %9\n\t";
            channel = channel.arg(((*data).mid(0,2)).toUInt(&ok,16))
            .arg(((*data).mid(4,2) + (*data).mid(2,2)).toUInt(&ok,16))
            .arg(((*data).mid(12,2) + (*data).mid(10,2)+ (*data).mid(8,2)+ (*data).mid(6,2)).toUInt(&ok,16))
            .arg(((*data).mid(20,2) + (*data).mid(18,2)+ (*data).mid(16,2)+ (*data).mid(14,2)).toUInt(&ok,16))
            .arg(((*data).mid(24,2) + (*data).mid(22,2)).toUInt(&ok,16))
            .arg(((*data).mid(28,2) + (*data).mid(26,2)).toUInt(&ok,16))
            .arg(((*data).mid(32,2) + (*data).mid(30,2)).toUInt(&ok,16))
            .arg(((*data).mid(36,2) + (*data).mid(34,2)).toUInt(&ok,16))
            .arg(((*data).mid(40,2) + (*data).mid(38,2)).toUInt(&ok,16));
    *data = channel;
}
void channelGGP(QString * data){
    bool ok;
    QString channel = "\n\tperiph_status : %1\n\t\
count_time : %2\n\t\
count : %3\n\t\
gk_uhv : %4\n\t\
gk_dac : %5\n\t\
temperature_internal : %6\n\t\
comp_edac_value : %7\n\t";
            channel = channel.arg(((*data).mid(0,2)).toUInt(&ok,16))
            .arg(((*data).mid(4,2) + (*data).mid(2,2)).toUInt(&ok,16))
            .arg(((*data).mid(12,2) + (*data).mid(10,2)+ (*data).mid(8,2)+ (*data).mid(6,2)).toUInt(&ok,16))
            .arg(((*data).mid(16,2) + (*data).mid(14,2)).toUInt(&ok,16))
            .arg(((*data).mid(20,2) + (*data).mid(18,2)).toUInt(&ok,16))
            .arg(((*data).mid(24,2) + (*data).mid(22,2)).toUInt(&ok,16))
            .arg(((*data).mid(28,2) + (*data).mid(26,2)).toUInt(&ok,16));
    *data = channel;
}
void channelGVK(QString * data){
    bool ok;
    QString channel = "\n\ttemperature_internal : %1\n\t\
locator_amp : %2\n\t\
locator_amp_interval_max : %3\n\t\
locator_amp_interval_min : %4\n\t\
gk_time : %5\n\t\
gk_impulses : %6\n\t\
gk_uhv : %7\n\t\
power_supply : %8\n\t\
temperature_external : %9\n\t\
temperature_external_2 : %10\n\t\
temperature_external_3 : %11\n\t\
p_corr : %12\n\t\
p_bw : %13\n\t\
acceleration_x : %14\n\t\
acceleration_y : %15\n\t\
acceleration_z : %16\n\t\
locator_amp : %17\n\t\
temperature_external_4 : %18\n\t\
gk_dac : %19\n\t";
            channel = channel.arg(((*data).mid(2,2) + (*data).mid(0,2)).toUInt(&ok,16))
            .arg(((*data).mid(6,2) + (*data).mid(4,2)).toUInt(&ok,16))
            .arg(((*data).mid(10,2) + (*data).mid(8,2)).toUInt(&ok,16))
            .arg(((*data).mid(14,2) + (*data).mid(12,2)).toUInt(&ok,16))
            .arg(((*data).mid(18,2) + (*data).mid(16,2)).toUInt(&ok,16))
            .arg(((*data).mid(22,2) + (*data).mid(20,2)).toUInt(&ok,16))
            .arg(((*data).mid(26,2) + (*data).mid(24,2)).toUInt(&ok,16))
            .arg(((*data).mid(30,2) + (*data).mid(28,2)).toUInt(&ok,16))
            .arg(((*data).mid(36,2) + (*data).mid(34,2)+ (*data).mid(32,2)).toUInt(&ok,16))
            .arg(((*data).mid(42,2) + (*data).mid(40,2)+ (*data).mid(38,2)).toUInt(&ok,16))
            .arg(((*data).mid(48,2) + (*data).mid(46,2)+ (*data).mid(44,2)).toUInt(&ok,16))
            .arg(((*data).mid(54,2) + (*data).mid(52,2)+ (*data).mid(50,2)).toUInt(&ok,16))
            .arg(((*data).mid(60,2) + (*data).mid(58,2)+ (*data).mid(56,2)).toUInt(&ok,16))
            .arg(((*data).mid(66,2) + (*data).mid(64,2)+ (*data).mid(62,2)).toUInt(&ok,16))
            .arg(((*data).mid(72,2) + (*data).mid(70,2)+ (*data).mid(68,2)).toUInt(&ok,16))
            .arg(((*data).mid(78,2) + (*data).mid(76,2)+ (*data).mid(74,2)).toUInt(&ok,16))
            .arg(((*data).mid(84,2) + (*data).mid(82,2)+ (*data).mid(80,2)).toUInt(&ok,16))
            .arg(((*data).mid(90,2) + (*data).mid(88,2)+ (*data).mid(86,2)).toUInt(&ok,16))
            .arg(((*data).mid(94,2) + (*data).mid(92,2)).toUInt(&ok,16));
    *data = channel;
}
void Parser38kModules::moduleDataParsing(PacketModulesData38k * moduleData){
    bool ok;
    QString * data = &moduleData->data;
    if(moduleData->header.data_state & 0x02){
        QString hardFlash = "<table border='1' >\
<tr><td colspan = '2' align='center'> HardFlash: </td></tr>\
<tr><td> total_length </td><td>  %1 </td></tr>\
<tr><td> device_type </td><td>  %2 </td></tr>\
<tr><td> device_number </td><td>  %3 </td></tr>\
<tr><td> production_day </td><td>  %4 </td></tr>\
<tr><td> production_month </td><td>  %5 </td></tr>\
<tr><td> production_year </td><td>  %6 </td></tr>\
<tr><td> device_name </td><td>  %7 </td></tr>\
<tr><td> device_code </td><td>  %8 </td></tr>\
<tr><td> device_decimal </td><td>  %9 </td></tr>\
<tr><td> flash_version </td><td>  %10 </td></tr>\
<tr><td> firmware_version </td><td>  %11 </td></tr>\
<tr><td> reserved </td><td>  %12 </td></tr>\
<tr><td> device_tag </td><td>  %13 </td></tr>\
<tr><td> device_length </td><td>  %14 </td></tr>\
<tr><td> device_tech_header_size </td><td>  %15 </td></tr>\
<tr><td> device_data_size </td><td>  %16 </td></tr>\
<tr><td> data_parts_max </td><td>  %17 </td></tr>";

        bool moduleAdded = false;
        ushort deviceType = *reinterpret_cast<ushort*>(moduleData->dataBytes.data()+2);
        ushort length = *reinterpret_cast<ushort*>(moduleData->dataBytes.data());
        if(listOfFoundModules->size() != 0)
            for(auto value = listOfFoundModules->begin();value < listOfFoundModules->end();value++)
                if(value->moduleAddress == moduleData->header.moduleAddress){
                    moduleAdded = true;
                    break;
                }
        if(!moduleAdded){
            NumberType module = {moduleData->header.moduleAddress,deviceType};
            listOfFoundModules->push_back(module);
        }
        hardFlash = hardFlash.arg(length).arg(deviceType)
        .arg(QTextCodec::codecForMib(106)->toUnicode(moduleData->dataBytes.mid(4,12).data()))
        .arg(*reinterpret_cast<uchar*>(moduleData->dataBytes.data()+16)).arg(*reinterpret_cast<uchar*>(moduleData->dataBytes.data()+17))
        .arg(*reinterpret_cast<ushort*>(moduleData->dataBytes.data()+18))
        .arg(QTextCodec::codecForMib(106)->toUnicode(moduleData->dataBytes.mid(20,16).data()))
        .arg(QTextCodec::codecForMib(106)->toUnicode(moduleData->dataBytes.mid(36,6).data()))
        .arg(QTextCodec::codecForMib(106)->toUnicode(moduleData->dataBytes.mid(42,6).data()))
        .arg(QString::number(*reinterpret_cast<uchar*>(moduleData->dataBytes.data()+48)) + "." + QString::number(*reinterpret_cast<uchar*>(moduleData->dataBytes.data()+49)))
        .arg(QString::number(*reinterpret_cast<uchar*>(moduleData->dataBytes.data()+50)) + "." + QString::number(*reinterpret_cast<uchar*>(moduleData->dataBytes.data()+51)))
        .arg("res")
        .arg(QTextCodec::codecForMib(106)->toUnicode(moduleData->dataBytes.mid(56,20).data()))
        .arg(*reinterpret_cast<ushort*>(moduleData->dataBytes.data()+76))
        .arg(*reinterpret_cast<ushort*>(moduleData->dataBytes.data()+78))
        .arg(*reinterpret_cast<uint*>(moduleData->dataBytes.data()+80))
        .arg(*reinterpret_cast<uchar*>(moduleData->dataBytes.data()+84));
        int numberOfChannels = (length-86)/8;
        for(int i = 0; i <  numberOfChannels;i++){
            hardFlash += "<tr><td colspan = '2' align='center' > %1 </td></tr>\
<tr><td> channel_mnemonics </td><td>  %2 </td></tr>\
<tr><td> channel_write_point </td><td>  %3 </td></tr>\
<tr><td> channel_flags </td><td>  %4 </td></tr>";
            hardFlash = hardFlash.arg("\n\tchannel " + QString::number(i) + ":").arg(*reinterpret_cast<uint*>(moduleData->dataBytes.data()+85+(i*8)))
            .arg(*reinterpret_cast<ushort*>(moduleData->dataBytes.data()+89+(i*8)))
            .arg(*reinterpret_cast<ushort*>(moduleData->dataBytes.data()+91+(i*8)));
        }
        hardFlash+= "<tr><td>CRC16</td><td>" + moduleData->dataBytes.mid(85+(numberOfChannels*8),2).toHex() + "</td></tr>";
        length = *reinterpret_cast<ushort*>(moduleData->dataBytes.data()+87);
        QString paramFlash = "<tr><td colspan = '2' align='center'> ParamFlash: </td></tr>";
        QByteArray paramFlashArray = moduleData->dataBytes.mid(87 +(numberOfChannels * 8),length);
        if(deviceType == 0)
           paramFlashGKT(paramFlash,paramFlashArray);
        else if(deviceType == 1)
           paramFlashSHM(paramFlash,paramFlashArray);
        else if(deviceType == 2)
           paramFlashAG(paramFlash,paramFlashArray);
        else if(deviceType == 3)
           paramFlashP(paramFlash,paramFlashArray);
        else if(deviceType == 7 || deviceType == 6)
           paramFlashP0204(paramFlash,paramFlashArray);
        else if(deviceType == 7 || deviceType == 6)
           paramFlashGVK(paramFlash,paramFlashArray);

        QString calibFlash = "<tr><td colspan = '2' align='center'>CalibFlash:</td></tr>" + moduleData->dataBytes.mid(87 +(numberOfChannels * 8) + (length)).toHex();
        *data = hardFlash + paramFlash + calibFlash + "</table>";
    }
    else if(!(moduleData->header.data_state & 0x01)){
        uint type = 124;
        if(listOfFoundModules->size() != 0)
            for(auto value = listOfFoundModules->begin();value < listOfFoundModules->end();value++)
                if(value->moduleAddress == moduleData->header.moduleAddress){
                    type = value->type;
                    break;
                }
        if(type == 0)
           ;//channelGKT(data);
        else if(type == 1)
           channelSHM(data,moduleData->header.currentPartNo);
        else if(type == 2)
           channelAG(data);
        else if(type == 7)
           channelP02(data);
    }
}
Parser38kModules::Parser38kModules(QList<PacketModulesData38k> *modulesData){
    this->modulesData = modulesData;
    this->listOfFoundModules = new QList<NumberType>;
    enabled = true;
    connect(this, SIGNAL(finished(void)), this, SLOT(del()));
}
void Parser38kModules::run(){
    for(auto value = modulesData->begin();value < modulesData->end(); value++)
        if(enabled)
            moduleDataParsing(&*value);
        else
           return;
}
void Parser38kModules::stop(){
    enabled = false;
}
void Parser38kModules::del(){
    this->~Parser38kModules();
}
Parser38kModules::~Parser38kModules(){
    delete this->listOfFoundModules;
    this->listOfFoundModules = nullptr;
}


void Parser38k::findModulesDataBytes(PacketDeviceData38k pack){
    bool ok;
    QByteArray moduleDataByteArray;
    int position = 0;
        dataBytes += pack.data.dataByte.mid(0);
        int size = dataBytes.size();
        while(position < size){
            PacketModulesData38k moduleData;
            moduleData.header.moduleAddress = *reinterpret_cast<unsigned char*>(dataBytes.data()+position);
            moduleData.header.data_state = *reinterpret_cast<unsigned char*>(dataBytes.data()+position+1);
            moduleData.header.totalSize = *reinterpret_cast<unsigned short*>((dataBytes.data()+position+2));
            if(moduleData.header.totalSize > size - position || moduleData.header.totalSize < 12)
                break;
            moduleDataByteArray = dataBytes.mid(position,moduleData.header.totalSize);
            moduleData.status =  crc.crcFast(reinterpret_cast<uchar*>(moduleDataByteArray.data()),moduleData.header.totalSize)?0x80:0;
            int posLastComSt = 0;
            if(moduleData.header.data_state & 0x80){
                moduleData.header.totalDataSize = moduleData.header.totalSize - 14;
                moduleData.header.totalParts = 1;
                moduleData.header.currentPartNo = 0;
            }
            else{
                moduleData.header.totalDataSize = *reinterpret_cast<unsigned short*>((dataBytes.data()+position+4));
                moduleData.header.totalParts = *reinterpret_cast<unsigned char*>(dataBytes.data()+position+6);
                moduleData.header.currentPartNo = *reinterpret_cast<unsigned char*>(dataBytes.data()+position+7);
                posLastComSt = 4;
            }
            int pos = position + posLastComSt + 4;
            moduleData.header.lastCommandState = *reinterpret_cast<unsigned char*>(dataBytes.data()+pos);
            moduleData.header.commandCounter = *reinterpret_cast<unsigned char*>(dataBytes.data()+pos+1);
            moduleData.header.lastCommandCrc = *reinterpret_cast<unsigned char*>(dataBytes.data()+pos+2);
            moduleData.header.lastCommandCode = *reinterpret_cast<unsigned char*>(dataBytes.data()+pos+3);
            moduleData.header.requestTime = *reinterpret_cast<uint*>(dataBytes.data()+pos+4);
            moduleData.dataBytes = moduleDataByteArray.mid(12,moduleData.header.totalSize - 14);
            //moduleDataParsing(&moduleData);
            emit  getModData38k(moduleData);
            position += moduleDataByteArray.size();
        }
        dataBytes = dataBytes.mid(position);
        position = 0;
        if(dataBytes.toHex() == "00")
            dataBytes.resize(0);
}
void Parser38k::findServiseFFFEBytes(TlmPack pack){
    bool ok;
    unsigned char array[255];
        QByteArray data = pack.dataPacketBytes.data.mid(2);
        QByteArray bl255;
        QByteArray byteArray;
        PacketDeviceData38k packetDeviceData;
        packetDeviceData.data.status = 0;
        for(int position = 0; position < data.length();position+=255 ){
            memset(array,0,255);
            bl255 = data.mid(position,255);
            memcpy(array,bl255.data(),bl255.size());
            int decod = cod.decode_rs_nasa(array);
            this->numberOfChecks++;
            this->numberOfError += decod?1:0;
            packetDeviceData.data.status |= decod;
            packetDeviceData.data.dataByte += bl255.mid(33);
        }

        QByteArray serv = packetDeviceData.data.dataByte.mid(0,12);
        memset(array,0,255);
        memcpy(array,serv.data(),12);
        this->numberOfChecks++;
        int crcF = crc.crcFast(array,12);
        if(crcF)
            this->numberOfError++;
        if((packetDeviceData.data.status == 2 && crcF) || serv.size() == 0){
            return;
        }
        packetDeviceData.data.dataByte = packetDeviceData.data.dataByte.mid(12);
        packetDeviceData.serv.systemTime = *reinterpret_cast<uint*>(serv.data());
        packetDeviceData.serv.transmissionCounter = *reinterpret_cast<unsigned short*>(serv.data()+4);
        packetDeviceData.serv.totalModules = *reinterpret_cast<unsigned char*>(serv.data()+6);
        packetDeviceData.serv.speedTelemetry = (*reinterpret_cast<unsigned char*>(serv.data()+7) << 4) & 0x0f;
        packetDeviceData.serv.bitDepthTelemetry = *reinterpret_cast<unsigned char*>(serv.data()+7) >> 4;
        packetDeviceData.serv.commandCounter = *reinterpret_cast<unsigned char*>(serv.data()+8);
        packetDeviceData.serv.reserved = *reinterpret_cast<unsigned char*>(serv.data()+9);
        packetDeviceData.serv.crc16 = *reinterpret_cast<unsigned short*>(serv.data()+10);
        findModulesDataBytes(packetDeviceData);
}
Parser38k::Parser38k(FileReader *file){
    this->tlmDeviceData = new QList<TlmPack>;
    this->byteArrayData = file->getByteArray();
    delete file;
    file = nullptr;
    connect(this, SIGNAL(finished()), this, SLOT(destroy()));
}

void Parser38k::run(){
    numberOfChecks = 0;
    numberOfError = 0;
    QTime time = QTime::currentTime();
    ParserTLM *parserTlm = new ParserTLM(this->byteArrayData);
    QList<BlockTlm> *tlmBlocks = parserTlm->getBlocks();
    for(auto block = tlmBlocks->begin();block < tlmBlocks->end();block++)
        for(auto pack = block->TlmPackList.begin();pack < block->TlmPackList.end();pack++)
            if(pack->dataPacketBytes.dev_type == "ADSP" && pack->dataPacketBytes.inf_type == "GETDATA"){
                findServiseFFFEBytes(*pack);
            }

    delete parserTlm;
    parserTlm = nullptr;
    double sr;
    if(numberOfError != 0 & numberOfChecks != 0)
         sr = numberOfError/(numberOfChecks/100);
    else
        sr = 100;

    this->probabilityOfError = sr;
}

void Parser38k::destroy(){
   this->~Parser38k();
}

Parser38k::~Parser38k(){
    delete this->tlmDeviceData;
    this->tlmDeviceData = nullptr;
    this->quit();
}
