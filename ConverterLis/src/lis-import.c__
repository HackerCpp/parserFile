#include <string.h>
#include <gio/gio.h>
#include <locale.h>
#include <glib/gstdio.h>
#include <time.h>

#include "datablock.h"
#include "program.h"
#include "unicode.h"
#include "top_bottom.h"

#define IN_CODESET		"866"

#define BUF_SIZE		4096

static const char8*		gfm_header_to_las_header[] = {
	"[COMP]",		"COMP",
	"[OPERATOR]",	"SRVC",
	"[PARTY]",		"PRTY",
	"[FIELD]",		"FLD",
	"[KUST]",		"KUST",
	"[WELL]",		"WELL",
	"[COMMENT]",	"COMM",
};

/* LAS format version default 2.0 */
static uint32	las_ver = 200;

static bool32	las_wrap_mode = FALSE;

static bool32 las_version( const char8 *str );
static void las_well_info( const char8 *str, GHashTable *las_header_table );
static void las_param_info( const char8 *str, GHashTable *las_header_table );
static void las_curve_info( const char8 *str, GString *db_header, uint32 *param_count, int32 *depth_idx, int32 *time_idx );
static bool32 las_data( const char8 *str, FILE *las_file, uint32 *line_num, uint32 param_count, int32 depth_idx, int32 time_idx,
						GOutputStream *param_out, GOutputStream *pos_out );

/* parse LAS string and extract components, return count of founded components */
static int32 parse_las_string( const char8 *pstr, char8 *mnem, char8 *unit, char8 *value, char8 *comment );
static char8* get_gfm_date( const char8 *str );

static char8* convert_las_header_to_gfm( GHashTable *las_header_table )
{
	GPtrArray	*gfm_keys;
	GHashTable	*gfm_to_las_hash;
	GHashTable	*las_header_keys_used;
	uint32		max_gfm_key_length;
	uint32		len32;
	char8		*buf8;
	char8		*pos;
	GString		*str;
	GHashTableIter	iter;
	int i;

	gfm_keys = g_ptr_array_new_with_free_func( g_free );
	gfm_to_las_hash = g_hash_table_new_full( g_str_hash, g_str_equal, g_free, g_free );
	max_gfm_key_length = 0;

	g_ptr_array_add( gfm_keys, g_strdup("[COMMENT]") );
	g_ptr_array_add( gfm_keys, g_strdup("[TOP]") );
	g_ptr_array_add( gfm_keys, g_strdup("[BOTTOM]") );
	g_ptr_array_add( gfm_keys, g_strdup("[DATE]") );
	g_ptr_array_add( gfm_keys, g_strdup("[END_DATE]") );
	g_ptr_array_add( gfm_keys, g_strdup("[TOOL]") );
	max_gfm_key_length = strlen("[END_DATE]");

	/* add static GFM keys */
	for( i = 0; i < G_N_ELEMENTS(gfm_header_to_las_header); i += 2 ){
		if( strcmp( gfm_header_to_las_header[i], "[COMMENT]" ) != 0 )
			g_ptr_array_add( gfm_keys, g_strdup(gfm_header_to_las_header[i]) );
		g_hash_table_insert( gfm_to_las_hash, g_strdup(gfm_header_to_las_header[i]), g_strdup(gfm_header_to_las_header[i+1]) );

		len32 = strlen(gfm_header_to_las_header[i]);
		max_gfm_key_length = MAX( len32, max_gfm_key_length );
	}

	las_header_keys_used = g_hash_table_new( g_str_hash, g_str_equal );
	pos = g_new( char8, max_gfm_key_length );
	memset( pos, ' ', max_gfm_key_length );
	str = g_string_new( "\n" );

	for( i = 0; i < gfm_keys->len; ++i ){
		/* searching gfm_keys[i] in las_header_table */
		buf8 = g_hash_table_lookup( las_header_table, gfm_keys->pdata[i] );

		if( buf8 == NULL ){
			/* use gfm_to_las_hash  */
			buf8 = g_hash_table_lookup( gfm_to_las_hash, gfm_keys->pdata[i] );
			if( buf8 != NULL ){
				g_hash_table_add( las_header_keys_used, buf8 );
				buf8 = g_hash_table_lookup( las_header_table, buf8 );
			}
		}
		else
			g_hash_table_add( las_header_keys_used, gfm_keys->pdata[i] );

		g_string_append_len( str, pos, max_gfm_key_length - strlen(gfm_keys->pdata[i]) );
		if( buf8 == NULL )
			/* gfm_keys[i] not found, add empty value */
			g_string_append_printf( str, "%s\n", (char8*)gfm_keys->pdata[i] );
		else
			g_string_append_printf( str, "%s %s\n", (char8*)gfm_keys->pdata[i], buf8 );
	}
	g_ptr_array_free( gfm_keys, TRUE );
	g_hash_table_destroy( gfm_to_las_hash );
	g_free( pos );

	/* add other keys from LAS header */
	g_hash_table_iter_init (&iter, las_header_table );
	while( g_hash_table_iter_next( &iter, (gpointer*)&buf8, (gpointer*)&pos ) == TRUE ){
		if( g_hash_table_contains( las_header_keys_used, buf8 ) == TRUE )
			continue;
		g_string_append_printf( str, "[%s] %s\n", buf8, pos );
	}
	g_hash_table_destroy( las_header_keys_used );

	return g_string_free( str, FALSE );
}

static char8* convert_to_utf8( const char8 *str, const char8 *from_codeset )
{
	char8	*out;

	out = g_convert( str, -1, "UTF-8", from_codeset, NULL, NULL, NULL );
	if( out == NULL )
		out = g_strdup( "" );
	return out;
}

/* return NULL-terminated string list for corresponding NULL-terminated header keys, return data should be freed by g_strfreev() */
EXPORT_API char8** import_file_header_list( const char8 *import_filepath, char8 **header_key )
{
	FILE			*las_file;
	char8			buf[BUF_SIZE];
	uint32			las_line_num;
	char8			section_symbol;
	GHashTable		*las_header_table;
	GHashTable		*gfm_to_las_key_hash;
	GPtrArray		*out;
	uint32			len32;
	char8			*buf8;
	char8			*str;
	int i;

	g_return_val_if_fail( import_filepath != NULL, NULL );
	g_return_val_if_fail( header_key != NULL, NULL );

	las_file = g_fopen( import_filepath, "rt" );
	g_return_val_if_fail( las_file != NULL, NULL );

	las_header_table = g_hash_table_new_full( g_str_hash, g_str_equal, g_free, g_free );
	las_line_num = 0;
	section_symbol = '\0';
	while( fgets( buf, BUF_SIZE, las_file) != NULL ){
		++las_line_num;
		switch( buf[0] ){

		case '~':
			section_symbol = buf[1];
			continue;
		case '#':
		case '\n':
		case '\0':
			continue;

		default:
			switch( section_symbol ){

			case 'V':
				if( las_version( buf ) == FALSE ){
					g_hash_table_destroy( las_header_table );
					fclose( las_file );
					return NULL;
				}
				break;

			case 'W':
				str = convert_to_utf8( buf, IN_CODESET );
				las_well_info( str, las_header_table );
				g_free( str );
				break;

			case 'P':
				str = convert_to_utf8( buf, IN_CODESET );
				las_param_info( str,las_header_table );
				g_free( str );
				break;
			}
			break;
		}
	}
	fclose( las_file );

	gfm_to_las_key_hash = g_hash_table_new_full( g_str_hash, g_str_equal, g_free, g_free );

	/* add static GFM keys */
	for( i = 0; i < G_N_ELEMENTS(gfm_header_to_las_header); i += 2 )
		g_hash_table_insert( gfm_to_las_key_hash, g_strdup(gfm_header_to_las_header[i]), g_strdup(gfm_header_to_las_header[i+1]) );

	/* add some key produced from [DATA] */
	str = g_hash_table_lookup( las_header_table, "[DATE]" );
	if( str != NULL ){
		/* extract [DATE_UNIX] [DATETIME] [TIME] and prepare [DATE] */
		buf8 = g_strrstr( str, "UNIX(" );
		if( buf8 != NULL ){
			g_hash_table_insert( gfm_to_las_key_hash, g_strdup("[DATE_UNIX]"), g_strdup("[DATE_UNIX]") );
			g_hash_table_insert( las_header_table, g_strdup("[DATE_UNIX]"), g_strdup( buf8 ) );
			*buf8 = 0;
		}
		buf8 = g_strrstr( str, "(GMT" );
		if( buf8 != NULL ){
			/* cutoff GMT data */
			*buf8 = 0;
		}
		g_strstrip( str );
		g_hash_table_insert( gfm_to_las_key_hash, g_strdup("[DATETIME]"), g_strdup("[DATE_TIME]") );
		g_hash_table_insert( gfm_to_las_key_hash, g_strdup("[DATE_TIME]"), g_strdup("[DATE_TIME]") );
		g_hash_table_insert( las_header_table, g_strdup("[DATE_TIME]"), g_strdup(str) );
		buf8 = strstr( str, " " );
		if( buf8 != NULL ){
			g_strstrip( buf8 );
			g_hash_table_insert( gfm_to_las_key_hash, g_strdup("[TIME]"), g_strdup("[TIME]") );
			g_hash_table_insert( las_header_table, g_strdup("[TIME]"), g_strdup( buf8 ) );
			/* cutoff time */
			*buf8 = 0;
			g_strstrip( str );
			/* now [DATE] contents shot date only */
		}
	}

	out = g_ptr_array_new();
	len32 = g_strv_length( header_key );

	for( i = 0; i < len32; ++i ){
		/* search in LAS hash table directly */
		buf8 = g_hash_table_lookup( las_header_table, header_key[i] );

		if( buf8 != NULL ){
			g_ptr_array_add( out, g_strdup( buf8 ) );
			continue;
		}

		/* header_keys in GFM hash table */
		buf8 = g_hash_table_lookup( gfm_to_las_key_hash, header_key[i] );

		if( buf8 == NULL ){
			g_ptr_array_add( out, g_strdup("") );
			continue;
		}

		/* search in LAS hash table */
		buf8 = g_hash_table_lookup( las_header_table, buf8 );

		if( buf8 == NULL ){
			g_ptr_array_add( out, g_strdup("") );
			continue;
		}

		g_ptr_array_add( out, g_strdup( buf8 ) );

	}
	g_ptr_array_add( out, NULL );

	g_hash_table_destroy( gfm_to_las_key_hash );
	g_hash_table_destroy( las_header_table );

	return (char8**)g_ptr_array_free( out, FALSE );
}

#define PARAMETER_TIME	"{}:TIME.SEC : FLOAT32\n"
#define PARAMETER_DEPTH	"{}:DEPTH.M : FLOAT32\n"

/* make import, return NULL if fail, on success return path to GFM-file, path should be free by g_free() */
EXPORT_API char8* import( const char8 *import_filepath )
{
	FILE 			*las_file;

	char8			*filename;
	char8			*filepath;

	GHashTable		*las_header_table;
	char8			section_symbol;
	uint32			las_line_num;
	char8			buf[BUF_SIZE];
	char8			*str8;

	GString			*db_header;
	GString			*str;
	uint32			param_count;
	int32			depth_idx;
	int32			time_idx;
	uint32			data_count;
	GFile			*tmp_file;
	GOutputStream	*param_out;
	GOutputStream	*pos_out;
	GInputStream	*in;

	GFile			*gfm;
	GOutputStream	*out;
	uint16			symbol;
	uint16			*str16;
	gsize			len;
	uint16			len16;
	uint32			len32;

	g_return_val_if_fail( import_filepath != NULL, NULL );

	las_file = g_fopen( import_filepath, "rt" );
	g_return_val_if_fail( las_file != NULL, NULL );

	/* check LAS version */
	las_line_num = 0;
	section_symbol = 0;
	while( fgets( buf, BUF_SIZE, las_file) != NULL ){
		++las_line_num;
		switch( buf[0] ){

		case '~':
			section_symbol = buf[1];
			continue;
		case '#':
		case '\n':
		case '\0':
			continue;

		default:
			if( section_symbol == 'V' ){
				if( las_version( buf ) == FALSE ){
					fclose( las_file );
					return NULL;
				}
				continue;
			}
			else if( section_symbol != 0 )
				break;
			continue;
		}
		break;
	}

	las_header_table = g_hash_table_new_full( g_str_hash, g_str_equal, g_free, g_free );
	db_header = g_string_new( NULL );
	param_count = 0;
	data_count = 0;
	depth_idx = -1;
	time_idx = -1;
	tmp_file = g_file_new_for_path( TMPDIR("tmp1", UTF8) );
	pos_out = G_OUTPUT_STREAM(g_file_replace( tmp_file, NULL, FALSE, G_FILE_CREATE_NONE, NULL, NULL ));
	g_object_unref( tmp_file );
	tmp_file = g_file_new_for_path( TMPDIR("tmp2", UTF8) );
	param_out = G_OUTPUT_STREAM(g_file_replace( tmp_file, NULL, FALSE, G_FILE_CREATE_NONE, NULL, NULL ));
	g_object_unref( tmp_file );
	while( fgets( buf, BUF_SIZE, las_file) != NULL ){
		++las_line_num;
		switch( buf[0] ){

		case '~':
			section_symbol = buf[1];
			if( section_symbol == 'O' ){
				if( depth_idx != -1 )
					--param_count;
				if( time_idx != -1 )
					--param_count;
			}
			continue;
		case '#':
		case '\n':
		case '\0':
			continue;

		default:
			switch( section_symbol ){

			case 'W':
				str8 = convert_to_utf8( buf, IN_CODESET );
				las_well_info( str8, las_header_table );
				g_free( str8 );
				break;

			case 'P':
				str8 = convert_to_utf8( buf, IN_CODESET );
				las_param_info( str8, las_header_table );
				g_free( str8 );
				break;

			case 'C':
				str8 = convert_to_utf8( buf, IN_CODESET );
				las_curve_info( str8, db_header, &param_count, &depth_idx, &time_idx );
				g_free( str8 );
				break;

			case 'O':
				str8 = convert_to_utf8( buf, IN_CODESET );
				// TODO process LAS other block
//				las_other_info( str8, las_header_table );
				g_free( str8 );
				break;

			case 'A':
				las_data( buf, las_file, &las_line_num, param_count, depth_idx, time_idx, param_out, pos_out );
				++data_count;
				break;
			}
			break;
		}
	}
	fclose( las_file );
	g_object_unref( param_out );
	g_object_unref( pos_out );

	g_print( "\n vector data count '%d'", data_count );

	/* extract import file name */
	filename = g_strrstr( import_filepath, "/" );
	if( filename == NULL )
		filename = g_strrstr( import_filepath, "\\" );
	if( filename == NULL )
		filename = g_strdup( import_filepath );
	else
		filename = g_strdup( filename + 1 );

	filepath = g_strdup( TMPDIR(filename, UTF8) );
	memcpy( filepath + strlen(filepath) - 3, "gfm", 3 );

	/* save temporary GFM file */
	gfm = g_file_new_for_path( filepath );
	out = G_OUTPUT_STREAM(g_file_replace( gfm, NULL, FALSE, G_FILE_CREATE_NONE, NULL, NULL ));
	g_object_unref( gfm );

	/* write UNICODE symbol */
	symbol = utf16_symbol( UT_DEFAULT );
	g_output_stream_write( out, &symbol, sizeof(symbol), NULL, NULL );

	/* write GFM signature */
	str16 = utf8_to_utf16( utf16_type( symbol ), GFM_FILE_SIGNATURE, -1, NULL, &len, NULL );
	g_output_stream_write( out, str16, len, NULL, NULL );
	g_free( str16 );

	/* HEADER  HEADER  HEADER  HEADER  HEADER  HEADER  HEADER  HEADER  HEADER  HEADER  HEADER */

	str8 = convert_las_header_to_gfm( las_header_table );
	g_return_val_if_fail( str8 != NULL, NULL );

	/* write block name (size and string) */
	str16 = utf8_to_utf16( utf16_type( symbol ), GFM_FILE_HEADER, -1, NULL, &len, NULL );
	len16 = len;
	g_output_stream_write( out, &len16, sizeof(len16), NULL, NULL );
	g_output_stream_write( out, str16, len, NULL, NULL );
	g_free( str16 );

	/* header block data to UNOCODE */
	str16 = utf8_to_utf16( utf16_type( symbol ), str8, -1, NULL, &len, NULL );
	g_free( str8 );
	/* write header block size */
	len32 = len;
	g_output_stream_write( out, &len32, sizeof(len32), NULL, NULL );
	/* write header block data */
	g_output_stream_write( out, str16, len32, NULL, NULL );
	g_free( str16 );

	g_hash_table_destroy( las_header_table );

	/* DATA BLOCK  DATA BLOCK  DATA BLOCK  DATA BLOCK  DATA BLOCK  DATA BLOCK  DATA BLOCK */

	str = g_string_new(	"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
						"<PARAMETERS>\n" );
//	if( time_idx != -1 ){
//		if( time_idx < depth_idx )
			g_string_append( str, PARAMETER_TIME PARAMETER_DEPTH );
//		else if( depth_idx != -1 )
//			g_string_append( str, PARAMETER_DEPTH PARAMETER_TIME );
//		else
//			g_string_append( str, PARAMETER_TIME );
//	}
//	else if( depth_idx != -1 )
//		g_string_append( str, PARAMETER_DEPTH );
//	else
//		g_return_val_if_reached( NULL );

	g_string_append_printf( str, "<SHORTCUT REF=\"{1}\" NAME=\"%s\"/>\n", filename );
	g_string_prepend_len( db_header, str->str, str->len );
	g_string_append( db_header, "</PARAMETERS>\n" );
	g_string_free( str, TRUE );

	/* write block name (size and string) */
	str16 = utf8_to_utf16( utf16_type( symbol ), GFM_FILE_DATA_BLOCK, -1, NULL, &len, NULL );
	len16 = len;
	g_output_stream_write( out, &len16, sizeof(len16), NULL, NULL );
	g_output_stream_write( out, str16, len, NULL, NULL );
	g_free( str16 );

	/* convert data block description to UNOCODE */
	str16 = char8bit_to_utf16( utf16_type( symbol ), db_header->str, db_header->len, "UTF8", NULL, &len, NULL );
	g_string_free( db_header, TRUE );
	/* calculate and write data block size */
	len32 = sizeof(len32) + len + data_count * (param_count + 2) * sizeof(float32) + 2*sizeof(symbol);
	g_output_stream_write( out, &len32, sizeof(len32), NULL, NULL );

	/* write data block description */
	len32 = len;
	g_output_stream_write( out, &len32, sizeof(len32), NULL, NULL );
	g_output_stream_write( out, str16, len32, NULL, NULL );
	g_free( str16 );

//	/* write data block binary data */
	tmp_file = g_file_new_for_path( TMPDIR("tmp1", UTF8) );
	in = G_INPUT_STREAM(g_file_read( tmp_file, NULL, NULL ));
	g_output_stream_splice( out, in, G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE, NULL, NULL );
	g_file_delete( tmp_file, NULL, NULL );
	g_object_unref( tmp_file );
	tmp_file = g_file_new_for_path( TMPDIR("tmp2", UTF8) );
	in = G_INPUT_STREAM(g_file_read( tmp_file, NULL, NULL ));
	g_output_stream_splice( out, in, G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE, NULL, NULL );
	g_file_delete( tmp_file, NULL, NULL );
	g_object_unref( tmp_file );

	/* write line-break */
	str16 = utf8_to_utf16( utf16_type( symbol ), "\n", -1, NULL, &len, NULL );
	g_output_stream_write( out, str16, len, NULL, NULL );
	g_free( str16 );

	g_object_unref( out );

	return filepath;
}

static bool32 las_version( const char8 *str )
{
	char8	mnem[BUF_SIZE], s1[BUF_SIZE], s2[BUF_SIZE], comm[BUF_SIZE];
	char8	*val;

	if( parse_las_string( str, mnem, s1, s2, comm ) < 2)
		return FALSE;

	if( s2[0] == '\0' )
		val = s1;
	else
		val = s2;

	if( strcmp( mnem, "VERS" ) == 0 ){
		las_ver = prog_strtod( val, NULL ) * 100.0;
		if( las_ver == 200 || las_ver == 120 )
			return TRUE;
		g_printerr( "\n ** Unknown LAS version '%s'", val );
		g_return_val_if_reached( FALSE );
	}
	else if( strncmp( mnem, "WRAP", 4 ) == 0 ){
		if( strcmp( "YES", val ) == 0 )
			las_wrap_mode = TRUE;
		else if( strcmp( "NO", val ) == 0 )
			las_wrap_mode = FALSE;
		else{
			g_printerr( "\n ** Unknown LAS wrap mode '%s'", val );
			g_return_val_if_reached( FALSE );
		}
		return TRUE;
	}
	return FALSE;
}

static void las_well_info( const char8 *str, GHashTable *las_header_table )
{
	static char8	date_time_buf[BUF_SIZE] = {0};

	char8	mnem[BUF_SIZE], unit[BUF_SIZE], val1[BUF_SIZE], val2[BUF_SIZE];

	if( parse_las_string( str, mnem, unit, val1, val2 ) == 0 )
		return;

	if( *mnem == '\0' )
		g_return_if_reached();

	if( strcmp( mnem, "STRT" ) == 0 && strcmp( unit, "M" ) == 0)
		g_hash_table_insert( las_header_table, g_strdup("[BOTTOM]"), g_strdup_printf( "%4.3lf (M)", prog_strtod( val1, NULL ) ) );
	else if( strcmp(mnem, "STOP") == 0 && strcmp( unit, "M" ) == 0 )
		g_hash_table_insert( las_header_table, g_strdup("[TOP]"), g_strdup_printf( "%4.3lf (M)", prog_strtod( val1, NULL ) ) );
	else if( strcmp(mnem, "DATE") == 0 )
		memcpy( date_time_buf, val1, strlen(val1) + 1 );
	else if( strcmp(mnem, "TIME") == 0 ){
		if( las_ver == 200 ){
			strcat( date_time_buf, " " );
			strcat( date_time_buf, val1 );
			g_hash_table_insert( las_header_table, g_strdup("[DATE]"), get_gfm_date( date_time_buf ) );
			*date_time_buf = '\0';
		}
		else
			g_hash_table_insert( las_header_table, g_strdup("[DATE]"), get_gfm_date( val2 ) );
	}
	else if( strcmp( mnem, "NULL" ) == 0 )
		return;
	else{
		if( las_ver == 200 )
			g_hash_table_insert( las_header_table, g_strdup(mnem), g_strdup(val1) );
		else
			g_hash_table_insert( las_header_table, g_strdup(mnem), g_strdup(val2) );
	}

}

static void las_param_info( const char8 *str, GHashTable *las_header_table )
{
	char8	mnem[BUF_SIZE], unit[BUF_SIZE], val1[BUF_SIZE], val2[BUF_SIZE];
	char8	*pos;

	if( str[0] != '[' ){
		if( parse_las_string( str, mnem, unit, val1, val2 ) == 0 )
			return;
	}
	else{
		/* LAS from GFM has no UNIT */
		unit[0] = '\0';

		/* extract MNEM */
		pos = strstr( str, "]" );
		if( pos == NULL || pos[1] == '\0' || pos[2] == '\0' )
			g_return_if_reached();
		pos[1] = '\0';
		strcpy( mnem, str );

		/* extract comment */
		str = pos + 2;
		pos = g_strrstr( str, ":" );
		if( pos != NULL ){
			strcpy( val2, pos + 1 );
			pos[0] = '\0';
		}
		else
			val2[0] = '\0';

		/* extract value */
		strcpy( val1, str );
		g_strstrip( val1 );

	}

	if( *mnem == '\0' )
		g_return_if_reached();

	if( las_ver == 200 )
		g_hash_table_insert( las_header_table, g_strdup(mnem), g_strdup(val1) );
	else
		g_hash_table_insert( las_header_table, g_strdup(mnem), g_strdup(val2) );
}

#define PARAMETER_MARK( NAME, MP ) \
	"{1}:" NAME " : FLOAT32 : " MP " (CM)  <desc draw_type=\"MARK\"/>\n"

#define PARAMETER_LINE( NAME, MP ) \
	"{1}:" NAME " : FLOAT32 : " MP " (CM)  <desc draw_type=\"LINE\"/>\n"

static void las_curve_info( const char8 *str, GString *db_header, uint32 *param_count, int32 *depth_idx, int32 *time_idx )
{
	char8	mnem[BUF_SIZE], unit[BUF_SIZE], val1[BUF_SIZE], val2[BUF_SIZE];

	if( parse_las_string( str, mnem, unit, val1, val2 ) == 0 )
		return;

	if( *mnem == '\0' )
		g_return_if_reached();

	if( strcmp( mnem, "DEPT" ) == 0 || strcmp( mnem, "DEPTH" ) == 0 )
		*depth_idx = *param_count;
	else if( strcmp( mnem, "TIME" ) == 0 || strcmp( mnem, "ETIM" ) == 0)
		*time_idx = *param_count;
	else if( strcmp( mnem, "MAPO" ) == 0 || (strcmp( mnem, "MARK" ) == 0 && strcmp( unit, "ADCU") != 0) || strcmp( mnem, "MMETKA" ) == 0 )
		g_string_append( db_header, PARAMETER_MARK( "MARK", "0" ) );
	else
		g_string_append_printf( db_header, PARAMETER_LINE( "%s(%s)", "%3.2f" ), mnem, unit, 0.0 );
	++(*param_count);
}

static inline bool32 is_blank( char8 c )
{
	return (c >= '\0' && c <= ' ');
}

/* skipping blank symbols, return TRUE of pointer at end of line */
static bool32 end_of( const char8 **str )
{
	char8 c;
	while( is_blank( c = **str ) == TRUE ){
		if(c == '\0')
			return TRUE;
		(*str)++;
	}
	return FALSE;
}

/* parse LAS string and extract components, return count of founded components */
static int32 parse_las_string( const char8 *pstr, char8 *mnem, char8 *unit, char8 *value, char8 *comment )
{
	char8 c;

	*mnem = *unit = *value = *comment = '\0';

	if( end_of( &pstr ) == TRUE )
		return 0;

	/* extracting MNEM */
	while( (c = *pstr++) != '.' ){
		if( is_blank( c ) == FALSE )
			*mnem++ = c;
		else if( end_of( &pstr ) == TRUE ){
			/* no other components */
			*mnem = '\0';
			return 1;
		}
	}
	*mnem = '\0';

	/* extracting UNIT */
	while( (c = *pstr++) != ':' ){
		if( is_blank( c ) == FALSE )
			*unit++ = c;
		else if( end_of( &pstr ) == TRUE ){
			/* no other components */
			*unit = '\0';
			return 2;
		}
		else
			break;
	}
	*unit = '\0';

	/* extracting value if pointer is not reached ':' separator */
	if( c != ':' ){
		while( (c = *pstr++) != ':' )
			if( (*value++ = c) =='\0' )
				break;
		*value = '\0';
		/* remove blank symbols at and of value */
		while( is_blank( *--value ) == TRUE )
			*value = '\0';
		if( c == '\0' )
			return 3;
	}

	/* extracting comments */
	if( end_of( &pstr ) == TRUE )
		return 3;
	while( *pstr != '\0' )
		*comment++ = *pstr++;
	/* remove blank symbols at and of comments */
	while( is_blank( *--comment ) == TRUE )
		*comment = '\0';

	return 4;
}

/* return current time zone name */
static const char8* get_current_timezone()
{
#ifdef G_OS_WIN32
	static char8	cur_time_zone[BUF_SIZE] = { '\0' };
	time64			gmt_offset_sec;

	_tzset();
	gmt_offset_sec = -_timezone;

	snprintf( cur_time_zone, BUF_SIZE, "GMT%+03d:%02d", (int32)gmt_offset_sec/3600, ((int32)gmt_offset_sec/60)%60 );

#else
	GTimeZone	*tz;
	const char8	*cur_time_zone;

	tz = g_time_zone_new_local();
	cur_time_zone = g_time_zone_get_abbreviation( tz, g_time_zone_find_interval( tz, G_TIME_TYPE_UNIVERSAL, get_current_time() ) );
	g_time_zone_unref( tz );

#endif

	return cur_time_zone;
}

const char8 *month[] = { "JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC" };
static char8* get_gfm_date( const char8 *str )
{
	struct tm	stime = { .tm_hour = 0, .tm_min = 0, .tm_sec = 0 };
	char		delim;
	int n = sscanf( str, "%d%c%d%c%d %d%c%d%c%d", &stime.tm_mday, &delim, &stime.tm_mon, &delim, &stime.tm_year,
			&stime.tm_hour, &delim, &stime.tm_min, &delim, &stime.tm_sec );
	if( n < 5 ){
		char str_month[4];
		n = sscanf( str, "%d%c%3c%c%d", &stime.tm_mday, &delim, str_month, &delim, &stime.tm_year );
		if( n == 5 )
			for( stime.tm_mon = 1; stime.tm_mon <= 12; stime.tm_mon++ )
				if( strncmp( str_month, month[stime.tm_mon-1], 3 ) == 0)
					break;
	}

	/* may be American date format */
	if(stime.tm_mon > 12){
		delim = stime.tm_mon;
		stime.tm_mon = stime.tm_mday;
		stime.tm_mday = delim;
	}
	if( stime.tm_year < 100 )
		stime.tm_year += 1900;
	if( stime.tm_year < 1970 )
		stime.tm_year += 100;
	if(n < 3)
		return NULL;

	stime.tm_year -= 1900;

	return g_strdup_printf( "%02d.%02d.%04d  %02d:%02d:%02d  (%s)  UNIX(%ld)",
			stime.tm_mday, stime.tm_mon, stime.tm_year + 1900, stime.tm_hour, stime.tm_min, stime.tm_sec,
			get_current_timezone(), mktime( &stime ) );
}

static uint32 scan_las_str( const char8 *str, float32* vals, uint32 param_count, float32 pos[2], int32 *idx, int32 depth_idx, int32 time_idx )
{
	uint32		n = 0;
	float32		d;
	char8		*err;

	while( n < param_count ){
		while( is_blank(*str) == TRUE && *str != '\0' )
			++str;
		if( *str == '\0' )
			return n;
		d = prog_strtod( str, &err );
		if( str == err )
			return n;
		++(*idx);
		if( *idx == time_idx )
			pos[0] = d;
		else if( *idx == depth_idx )
			pos[1] = d;
		else{
			*vals++ = d;
			++n;
		}
		str = err;
		if( *str == '\0' )
			return n;
	}
	return n;
}

static bool32 las_data( const char8 *str, FILE *las_file, uint32 *line_num, uint32 param_count, int32 depth_idx, int32 time_idx,
						GOutputStream *param_out, GOutputStream *pos_out )
{
	float32		vals[param_count];
	float32		pos[2] = { 0, 0 };
	uint32		read_count;
	int32		idx;
	char8		buf[BUF_SIZE];

	idx = -1;
	read_count = scan_las_str( str, vals, param_count, pos, &idx, depth_idx, time_idx );
	if( las_wrap_mode == TRUE ){
		if( read_count != 0 || idx != 0 ){
			g_printerr( "\n ** Error parsing multiline LAS " );
			g_return_val_if_reached( FALSE );
		}

		while( read_count < param_count ){
			if( fgets( buf, BUF_SIZE, las_file ) == NULL )
				g_return_val_if_reached( FALSE );
			++(line_num);
			read_count += scan_las_str( buf, vals + read_count, param_count - read_count, pos, &idx, depth_idx, time_idx );
		}
	}
	if( read_count != param_count ){
		g_printerr( "\n ** Error parsing LAS parameters read '%d'  curves '%d'  line #'%d'", read_count, param_count, *line_num - 1 );
		g_return_val_if_reached( FALSE );
	}

//	ValidateValues(p); // заменить недействительные значения на #1.QNAN
	g_output_stream_write( param_out, vals, sizeof(vals), NULL, NULL );
	g_output_stream_write( pos_out, pos, sizeof(pos), NULL, NULL );

	return TRUE;
}
